<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



















  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/custom/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/custom/favicon.ico?v=6.6.0">










<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文是【黑马程序员JVM完整教程，全网超高评价，全程干货不拖沓-哔哩哔哩】教学视频学习所做的笔记  部分笔记内容拷贝自【JVM学习】   一、什么是JVM定义Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） 好处 一次编写，到处运行 自动内存管理，垃圾回收机制 数组下标越界检查  比较JVM JRE JDK的区别  常见JVM 二、内存结构  程序">
<meta name="keywords" content="jvm">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马程序员JVM学习笔记">
<meta property="og:url" content="http://yoursite.com/Java/黑马程序员JVM学习笔记/index.html">
<meta property="og:site_name" content="咸鱼">
<meta property="og:description" content="本文是【黑马程序员JVM完整教程，全网超高评价，全程干货不拖沓-哔哩哔哩】教学视频学习所做的笔记  部分笔记内容拷贝自【JVM学习】   一、什么是JVM定义Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） 好处 一次编写，到处运行 自动内存管理，垃圾回收机制 数组下标越界检查  比较JVM JRE JDK的区别  常见JVM 二、内存结构  程序">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/学习路线.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/JVM_JRE_JDK的区别.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/常见JVM.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/学习路线.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/虚拟机栈.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/虚拟机栈演示图.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/虚拟机栈演示DEBUG.jpg">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/线程安全演示.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/jstack发现死锁.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/死锁代码.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/本地方法栈.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/堆.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/堆内存溢出演示代码.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/堆内存溢出异常.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/堆内存诊断演示代码.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/jmap.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/jconsole.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/jvisualvm_1.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/jvisualvm_2.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/jvisualvm_3.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/jvisualvm_4.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/方法区.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/方法区组成.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/StringTable的位置.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/直接内存1.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/直接内存2.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/循环引用.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/GC_Roots.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/垃圾回收五种引用.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/垃圾回收软引用.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/垃圾回收弱引用.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/垃圾回收终结器引用.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/软引用-示例代码.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/软引用清理-示例代码.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/弱引用-示例代码.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/回收算法-标记.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/回收算法-标记整理.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/回收算法-复制-标记垃圾内存.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/回收算法-复制-移动有用对象到TO区.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/回收算法-复制-清空FROM区的垃圾.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/回收算法-交换FROM-TO区.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/分代回收.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/分代回收VM参数.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/垃圾回收器-串行.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/垃圾回收器-吞吐量优先.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/垃圾回收器-响应时间优先.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/G1_新生代.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/G1_YoungCollection_1.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/G1_YoungCollection_2.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/G1_YoungCollection_3.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/G1_YoungCollection_CM.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/G1_YoungCollection_MIXED.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/脏卡0.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/脏卡2.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/remark_0.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/remark_1.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/remark_2.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/巨型对象0.png">
<meta property="og:image" content="http://yoursite.com/images/java/jvm/巨型对象1.png">
<meta property="og:updated_time" content="2021-12-28T03:24:10.155Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黑马程序员JVM学习笔记">
<meta name="twitter:description" content="本文是【黑马程序员JVM完整教程，全网超高评价，全程干货不拖沓-哔哩哔哩】教学视频学习所做的笔记  部分笔记内容拷贝自【JVM学习】   一、什么是JVM定义Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） 好处 一次编写，到处运行 自动内存管理，垃圾回收机制 数组下标越界检查  比较JVM JRE JDK的区别  常见JVM 二、内存结构  程序">
<meta name="twitter:image" content="http://yoursite.com/images/java/jvm/学习路线.png">






  <link rel="canonical" href="http://yoursite.com/Java/黑马程序员JVM学习笔记/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>黑马程序员JVM学习笔记 | 咸鱼</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">咸鱼</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">咸鱼是以盐腌渍后，晒干的鱼</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-jdk新特性">

    
    
    
      
    

    

    <a href="/jdk-features/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>JDK新特性</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-java资源">

    
    
    
      
    

    

    <a href="/awesome-java/" rel="section"><i class="menu-item-icon fa fa-fw fa-code"></i> <br>Java资源</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-hexo">

    
    
    
      
    

    

    <a href="/hexo/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>hexo</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Java/黑马程序员JVM学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinWen">
      <meta itemprop="description" content="做人如果没有梦想,和咸鱼有什么区别呢?">
      <meta itemprop="image" content="/images/custom/avatar_samwen.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咸鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">黑马程序员JVM学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-08-03 21:52:36" itemprop="dateCreated datePublished" datetime="2020-08-03T21:52:36+08:00">2020-08-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-12-28 11:24:10" itemprop="dateModified" datetime="2021-12-28T11:24:10+08:00">2021-12-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文是<a href="https://b23.tv/AYSxdj" target="_blank" rel="noopener"><strong>【黑马程序员JVM完整教程，全网超高评价，全程干货不拖沓-哔哩哔哩】</strong></a>教学视频学习所做的笔记</p>
<blockquote>
<p>部分笔记内容拷贝自<a href="https://nyimac.gitee.io/2020/07/03/JVM%E5%AD%A6%E4%B9%A0/#1%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8" target="_blank" rel="noopener">【JVM学习】</a></p>
</blockquote>
<p><img src="/images/java/jvm/学习路线.png" alt></p>
<h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
<li>数组下标越界检查</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>JVM JRE JDK的区别</p>
<p><img src="/images/java/jvm/JVM_JRE_JDK的区别.png" alt></p>
<h3 id="常见JVM"><a href="#常见JVM" class="headerlink" title="常见JVM"></a>常见JVM</h3><p><img src="/images/java/jvm/常见JVM.png" alt></p>
<h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><p><img src="/images/java/jvm/学习路线.png" alt></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p>作用：用于保存JVM中下一条所要执行的指令的地址</p>
<p>特点：</p>
<ul>
<li>线程私有<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一行指令</li>
</ul>
</li>
<li>不会存在内存溢出</li>
</ul>
<h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><p><img src="/images/java/jvm/虚拟机栈.png" alt="虚拟机栈"></p>
<h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>Java Virtual Machine Stacks (Java虚拟机栈)</p>
<ul>
<li>每个<strong>线程</strong>运行时所需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧(Frame)</strong>组成，对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
</ul>
<p><img src="/images/java/jvm/虚拟机栈演示图.png" alt></p>
<p>演示代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		method1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		method2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = a + b;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/java/jvm/虚拟机栈演示DEBUG.jpg" alt></p>
<p><strong>问题辨析：</strong></p>
<ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
<li><code>-Xss size</code> 指定栈内存大小，一般无需指定，使用默认的即可。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>变量是否线程安全，要看此变量是线程共享的，还是私有的？</li>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
<li><img src="/images/java/jvm/线程安全演示.png" alt="线程安全演示"></li>
</ul>
</li>
</ul>
<h4 id="2-2-内存溢出"><a href="#2-2-内存溢出" class="headerlink" title="2.2 内存溢出"></a>2.2 内存溢出</h4><p>栈内存溢出错误： <code>Java.lang.stackOverflowError</code></p>
<p>发生原因：</p>
<ul>
<li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li>
<li>虚拟机栈中，<strong>栈帧过大</strong> (不容易出现)</li>
</ul>
<h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>案例1：CPU占用过多</p>
<ul>
<li><p>演示代码：<code>while(true){...}</code>，<code>nohup</code> 运行</p>
</li>
<li><p><code>top</code> 查看进程 PID 占用情况</p>
</li>
<li><code>ps H -eo pid, tid, %cpu | grep 具体PID</code> 查看某进程(pid)中的线程(tid)占用CPU的详细情况</li>
<li><code>jstack PID</code> 查看进程所有线程的nid (16进制)，tid是10进制值，转换nid或tid比对，可以定位到线程的哪行代码出了问题。</li>
</ul>
<p>案例2：程序运行很久都没有结果</p>
<ul>
<li>演示代码：死锁</li>
<li><code>jstack PID</code> 查看线程运行情况，能看到死锁信息</li>
<li><img src="/images/java/jvm/jstack发现死锁.png" alt></li>
<li><img src="/images/java/jvm/死锁代码.png" alt></li>
</ul>
<h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p><img src="/images/java/jvm/本地方法栈.png" alt="本地方法栈"></p>
<p>一些带有 <strong>native</strong> 关键字的方法，Java调用C/C++方法。</p>
<p><strong>本地方法栈</strong> 的作用就是为 <strong>本地方法</strong> 的运行提供内存空间。</p>
<h3 id="4、堆-Heap"><a href="#4、堆-Heap" class="headerlink" title="4、堆(Heap)"></a>4、堆(Heap)</h3><p><img src="/images/java/jvm/堆.png" alt="堆"></p>
<blockquote>
<p>前面1.2.3点的 “栈” 都是线程 “私有” 的区，而 “堆” 和 “方法区” 是线程共享的区。</p>
</blockquote>
<p>定义：通过new关键字创建的对象都会被放在<strong>堆</strong>内存</p>
<p>特点</p>
<ul>
<li>所有线程共享，堆内存中的对象都需要考虑线程安全问题</li>
<li>有垃圾回收机制</li>
</ul>
<h4 id="4-1-堆内存溢出"><a href="#4-1-堆内存溢出" class="headerlink" title="4.1 堆内存溢出"></a>4.1 堆内存溢出</h4><blockquote>
<p>堆内存虽然有垃圾回收，但如果不断产生新的对象，而产生的对象一直有引用，那么无法垃圾回收，堆内存将会耗尽，也就是堆内存溢出。</p>
</blockquote>
<p><code>-Xmx Size</code> 参数指定堆内存大小</p>
<p><img src="/images/java/jvm/堆内存溢出演示代码.png" alt="堆内存溢出演示代码"></p>
<p><img src="/images/java/jvm/堆内存溢出异常.png" alt="堆内存溢出异常"></p>
<h4 id="4-2-堆内存诊断"><a href="#4-2-堆内存诊断" class="headerlink" title="4.2 堆内存诊断"></a>4.2 堆内存诊断</h4><ol>
<li><p><strong>jps</strong> 工具</p>
<p>命令行查看当前系统中Java进程</p>
</li>
<li><p><strong>jmap</strong> 工具</p>
<p>命令行查看某时刻堆内存占用情况</p>
<blockquote>
<p>OracleJDK运行没问题，但OpenJDK可能无法直接运行：</p>
<p>$ jmap -heap 37420<br>Error: -heap option used<br>Cannot connect to core dump or remote debug server. Use jhsdb jmap instead</p>
</blockquote>
<p><img src="/images/java/jvm/堆内存诊断演示代码.png" alt></p>
<p><img src="/images/java/jvm/jmap.png" alt></p>
</li>
<li><p><strong>jconsole</strong> 工具</p>
<p>图形界面多功能监控工具，可以连续监测</p>
<p><img src="/images/java/jvm/jconsole.png" alt></p>
</li>
<li><p><strong>jvisualvm</strong> 工具</p>
<p>图形界面多功能监控工具，可以连续监测，可以对堆内存抓取快照，以下是示例：</p>
<p><img src="/images/java/jvm/jvisualvm_1.png" alt></p>
<p><img src="/images/java/jvm/jvisualvm_2.png" alt></p>
<p><img src="/images/java/jvm/jvisualvm_3.png" alt></p>
<p><img src="/images/java/jvm/jvisualvm_4.png" alt></p>
</li>
</ol>
<h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><p><img src="/images/java/jvm/方法区.png" alt><br><strong>方法区</strong>的定义摘自<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html" target="_blank" rel="noopener">【JVM 规范】</a> 翻译 ：</p>
<ul>
<li>Java虚拟机中有一个被所有线程<strong>共享</strong>的<strong>方法区</strong>。它存储着每个类的结构(structures)信息，譬如<strong>运行时的常量池(run-time constant pool)，字段(field)，方法数据(medthod data)，以及方法和构造方法的代码</strong>，包括一些在类和实例初始化和接口初始化时候使用的特殊方法。</li>
<li><strong>方法区</strong>在<strong>JVM启动</strong>时候被创建。虽然方法区在逻辑层面上是堆的一部分(具体由厂商实现，如IBM，Oracle等)，但是就简单实现来说既不会被回收也不会被压缩。这个规范并<strong>不强制指定方法区存放的位置</strong>也不会对编译过的代码有管理策略的限制（oraclejdk 1.8和1.7及之前实现就不一样）。</li>
<li>方法区可能有一个固定的大小或者也可以通过计算大小去扩展也可以在不需要的时候被压缩。</li>
<li>方法区的内存也不需要是连续的。</li>
<li>Jvm虚拟机实现可以提供给编程人员或者用户初始化方法区的大小，同时在方法区可变大小的情况下，控制这个方法区的最大值和最小值。</li>
<li>和方法区有关联的异常情况：如果方法区满足不了构造所需要的内存，JVM就会抛出内存溢出错误：<strong>OutOfMemoryError</strong>。</li>
</ul>
<p><strong>JVM内存结构示意图：</strong><br><img src="/images/java/jvm/方法区组成.png" alt="JVM内存结构"></p>
<h4 id="5-1-内存溢出"><a href="#5-1-内存溢出" class="headerlink" title="5.1 内存溢出"></a>5.1 内存溢出</h4><ul>
<li>1.8以前会导致<strong>永久代(PermGen)</strong>内存溢出<br>参数<code>-XX:MaxPermSize=8m</code> 可以测试导致错误： <code>java.lang.OutOfMemoryError: PermGen space</code></li>
<li>1.8以后会导致<strong>元空间(Metaspace)</strong>内存溢出<br>参数<code>-XX:MaxMetaspaceSize=8m</code> 可以测试导致错误： <code>java.lang.OutOfMemoryError: Metaspace</code></li>
</ul>
<p>加载过多的class会导致内存溢出，实际项目中容易出现该错误的常见场景有：spring 、mybatis等大型框架。</p>
<h4 id="5-2-常量池"><a href="#5-2-常量池" class="headerlink" title="5.2 常量池"></a>5.2 常量池</h4><p>二进制字节码的组成：<strong>类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</strong></p>
<p>常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</p>
<h4 id="5-3-运行时常量池"><a href="#5-3-运行时常量池" class="headerlink" title="5.3 运行时常量池"></a>5.3 运行时常量池</h4><p>常量池是在 <code>*.class</code> 文件中的，当该<strong>class类被加载以后</strong>，它的常量池信息就会放入<strong>运行时常量池</strong>，并把里面的<strong>符号地址变为真实内存地址</strong></p>
<h4 id="5-4-串池-StringTable"><a href="#5-4-串池-StringTable" class="headerlink" title="5.4 串池(StringTable)"></a>5.4 串池(StringTable)</h4><p>StringTable是<strong>字符串常量池</strong>（简称串池），其数据结构上是一个 hash 表，字符串对象就充当 hash 表中的 key，key 的不重复性，是 hash 表的基本特性。它是jdk用来解决以new的方式创建字符串对象的一个缺点：堆内存中会存在大量重复的字符串，占用内存。</p>
<h5 id="5-4-1-StringTable的特性："><a href="#5-4-1-StringTable的特性：" class="headerlink" title="5.4.1 StringTable的特性："></a>5.4.1 StringTable的特性：</h5><ul>
<li>常量池中的字符串仅是符号，只有在<strong>被用到时才会转化为对象</strong></li>
<li>利用<strong>串池</strong>的机制，来避免重复创建<strong>字符串对象</strong></li>
<li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li>
<li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li>
<li>可以使用<strong>String.intern()方法</strong>，主动将串池中还没有的<strong>字符串对象</strong>放入串池中</li>
<li><strong>注意</strong>：无论是<strong>串池</strong>还是<strong>堆</strong>里面的字符串，都是对象</li>
</ul>
<blockquote>
<p>注意：示例运行的环境：</p>
<p>openjdk version “1.8.0_141”<br>OpenJDK Runtime Environment (build 1.8.0_141-8u141-b15-3~14.04-b15)<br>OpenJDK 64-Bit Server VM (build 25.141-b15, mixed mode)</p>
</blockquote>
<h6 id="StringTable示例1："><a href="#StringTable示例1：" class="headerlink" title="StringTable示例1："></a>StringTable示例1：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String a = <span class="string">"a"</span>; </span><br><span class="line">		String b = <span class="string">"b"</span>;</span><br><span class="line">		String ab = <span class="string">"ab"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>javap -v StringTableStudy.class</code>反编译结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #2                  // String a</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         3: ldc           #3                  // String b</span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         6: ldc           #4                  // String ab</span><br><span class="line">         <span class="number">8</span>: astore_3</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong></li>
<li>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，<strong>并放入串池中</strong></li>
<li>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，<strong>并放入串池中</strong></li>
</ul>
<ul>
<li>最终串池 <strong>StringTable [“a”, “b”, “ab”]</strong></li>
</ul>
<p>总结：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
<h6 id="StringTable示例2："><a href="#StringTable示例2：" class="headerlink" title="StringTable示例2："></a>StringTable示例2：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String a = <span class="string">"a"</span>; </span><br><span class="line">		String b = <span class="string">"b"</span>;</span><br><span class="line">		String ab = <span class="string">"ab"</span>;</span><br><span class="line">		<span class="comment">//拼接字符串对象来创建新的字符串</span></span><br><span class="line">		String ab2 = a+b; <span class="comment">//分析此行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>javap -v StringTableStudy.class</code>反编译结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #2                  // String a</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         3: ldc           #3                  // String b</span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         6: ldc           #4                  // String ab</span><br><span class="line">         <span class="number">8</span>: astore_3</span><br><span class="line">         9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">        <span class="number">12</span>: dup</span><br><span class="line">        13: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        <span class="number">27</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">29</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>只分析最后一行代码</p>
<ul>
<li>9: new #5  new一个StringBuilder对象</li>
<li>13: invokespecial #6  执行StringBuilder的构造方法</li>
<li>16: aload_1加载 参数astore_1</li>
<li>17: invokevirtual #7 调用append方法</li>
<li>20: aload_2 加载 参数astore_2</li>
<li>21: invokevirtual #7 调用append方法</li>
<li>24: invokevirtual #8  toString()方法，new一个在堆内存的对象</li>
<li>27: astore        4 把toString()的对象存储</li>
</ul>
<p><code>String ab2 = a+b;</code> 创建字符串的过程是 <code>StringBuilder().append(“a”).append(“b”).toString()</code></p>
<p>再看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>; </span><br><span class="line">        String b = <span class="string">"b"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存放在串池中</span></span><br><span class="line">        String ab = <span class="string">"ab"</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//存放在堆内存</span></span><br><span class="line">        <span class="comment">//StringBuilder().append(“a”).append(“b”).toString()</span></span><br><span class="line">        String ab2 = a+b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结果是false，因为两者的存放位置不同</span></span><br><span class="line">        System.out.println(ab == ab2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="StringTable示例3："><a href="#StringTable示例3：" class="headerlink" title="StringTable示例3："></a>StringTable示例3：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>;</span><br><span class="line">        String b = <span class="string">"b"</span>;</span><br><span class="line">        String ab = <span class="string">"ab"</span>;</span><br><span class="line">        String ab2 = a+b;</span><br><span class="line">        String ab3 = <span class="string">"a"</span> + <span class="string">"b"</span>; <span class="comment">//分析此行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>javap -v StringTableStudy.class</code>反编译结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">6</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #2                  // String a</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         3: ldc           #3                  // String b</span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         6: ldc           #4                  // String ab</span><br><span class="line">         <span class="number">8</span>: astore_3</span><br><span class="line">         9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">        <span class="number">12</span>: dup</span><br><span class="line">        13: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        <span class="number">27</span>: astore        <span class="number">4</span></span><br><span class="line">        29: ldc           #4                  // String ab</span><br><span class="line">        <span class="number">31</span>: astore        <span class="number">5</span></span><br><span class="line">        <span class="number">33</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>直接看 <code>29: ldc</code> ：javac在编译期会进行优化，结果已在编译期确定为ab，而创建ab的时候已经在串池中放入了字符串“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</p>
<h5 id="5-4-2-intern方法"><a href="#5-4-2-intern方法" class="headerlink" title="5.4.2 intern方法"></a>5.4.2 intern方法</h5><p>调用字符串对象的intern方法，主动将串池中还没有的字符串对象放入到串池。</p>
<p>intern示例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//"a" "b" 被放入串池中，s则存在于堆内存之中</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//尝试将堆中s对象放入串池，</span></span><br><span class="line">        <span class="comment">//串池中如果已存在此字符串并不会放入;</span></span><br><span class="line">        <span class="comment">//串池中如果不存在此字符串则会放入串池，并把串池中的对象返回;</span></span><br><span class="line">        <span class="comment">//此时串池中没有"ab"，则s会放入到串池，并返回给s2</span></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//s3赋值，因为此时串池中已有"ab"，则直接将串池中的内容返回</span></span><br><span class="line">        String s3 = <span class="string">"ab"</span>;</span><br><span class="line">        <span class="comment">//因为堆内存与串池中的"ab"是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class="line">        System.out.println(str == st2);</span><br><span class="line">        System.out.println(str == str3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>intern示例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//"ab"被放入串池中</span></span><br><span class="line">        String x = <span class="string">"ab"</span>;</span><br><span class="line">        <span class="comment">//"a" "b" 被放入串池中，s则存在于堆内存之中</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//尝试将堆中s对象放入串池，</span></span><br><span class="line">        <span class="comment">//串池中已有"ab"，则s不会放入到串池(s依然是堆中的对象)，并返回串池中的"ab"给s2</span></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line">        </span><br><span class="line">        System.out.println(s2 == x);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s == x); <span class="comment">//false，堆 != 串池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>intern在JDK1.8和1.6上的区别：</p>
<ul>
<li><p>1.8 </p>
<p>将字符串对象尝试放入串池，如已存在则不放入，会把串池中的对象返回；如不存在则<strong>把对象</strong>放入串池，会把串池中的对象返回</p>
</li>
<li><p>1.6</p>
<p>将字符串对象尝试放入串池，如已存在则不放入，会把串池中的对象返回；如不存在则<strong>把对象复制一份</strong>放入串池，会把串池中的对象返回</p>
</li>
</ul>
<h5 id="5-4-3-StringTable的位置"><a href="#5-4-3-StringTable的位置" class="headerlink" title="5.4.3  StringTable的位置"></a>5.4.3  StringTable的位置</h5><p><img src="/images/java/jvm/StringTable的位置.png" alt></p>
<ul>
<li>1.8 在堆内存中 (回收效率高)</li>
<li>1.6 在永久代PermGen (触发垃圾回收时间晚，回收效率不高)</li>
</ul>
<h5 id="5-4-4-StringTable垃圾回收"><a href="#5-4-4-StringTable垃圾回收" class="headerlink" title="5.4.4 StringTable垃圾回收"></a>5.4.4 StringTable垃圾回收</h5><p>​    StringTable在内存紧张时，会发生垃圾回收</p>
<h5 id="5-4-5-StringTable调优"><a href="#5-4-5-StringTable调优" class="headerlink" title="5.4.5 StringTable调优"></a>5.4.5 StringTable调优</h5><ul>
<li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑是否需要将字符串对象入池</p>
<p>可以通过<strong>intern方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul>
<li>常见于NIO操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<p><strong>JVM常规</strong>文件IO流程(要调用“操作系统方法”操作IO)</p>
<p><img src="/images/java/jvm/直接内存1.png" alt></p>
<p><strong>JVM直接内存</strong>文件IO流程(直接操作IO)</p>
<p><img src="/images/java/jvm/直接内存2.png" alt></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率。</p>
<p>直接内存溢出：<code>java.lang.OutOfMemoryError:Direct buffer memory</code></p>
<p><strong>直接内存分配</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"><span class="comment">//通过ByteBuffer申请1M的直接内存</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure>
<p><strong>直接内存释放</strong></p>
<p>JVM并不能回收直接内存中的内容，它是如何实现回收的呢？看分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接内存示例</span></span><br><span class="line"><span class="comment">//Windows上要通过任务管理器查看内存情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1G = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1G);</span><br><span class="line">        System.out.println(<span class="string">"分配直接内存完毕"</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">"开始释放直接内存"</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();<span class="comment">//显示垃圾回收，Full GC</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ByteBuffer.allocateDirect()</code> 这个方法的实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new direct byte buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's position will be zero, its limit will be its</span></span><br><span class="line"><span class="comment"> * capacity, its mark will be undefined, each of its elements will be</span></span><br><span class="line"><span class="comment"> * initialized to zero, and its byte order will be</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ByteOrder#BIG_ENDIAN BIG_ENDIAN&#125;.  Whether or not it has a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #hasArray backing array&#125; is unspecified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  capacity</span></span><br><span class="line"><span class="comment"> *         The new buffer's capacity, in bytes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the &#123;<span class="doctag">@code</span> capacity&#125; is a negative integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>DirectByteBuffer</code> 类构造函数实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary constructor</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//申请内存</span></span><br><span class="line">        base = UNSAFE.allocateMemory(size); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    UNSAFE.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Cleaner是虚引用类型 PhantomReference&lt;Object&gt;</span></span><br><span class="line">    <span class="comment">//特点：当所关联的对象被回收，Cleaner会触发clean()方法</span></span><br><span class="line">    <span class="comment">//这里关联的是对象this就是DirectByteBuffer,当DirectByteBuffer被回收触发Cleaner.clean()</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Deallocator回调任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">            <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Paranoia</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放直接内存</span></span><br><span class="line">            UNSAFE.freeMemory(address);</span><br><span class="line">            address = <span class="number">0</span>;</span><br><span class="line">            Bits.unreserveMemory(size, capacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>Cleaner.clean()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Runs this cleaner, if it has not been run before.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!remove(<span class="keyword">this</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用run方法，也就是上面的回调任务Deallocator.run()方法</span></span><br><span class="line">        thunk.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable x) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (System.err != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">new</span> Error(<span class="string">"Cleaner terminated abnormally"</span>, x)</span><br><span class="line">                    .printStackTrace();</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>使用了 <code>Unsafe</code> 对象完成直接内存的分配回收，并且回收需要主动调用 <code>Unsafe.freeMemory()</code> 方法</li>
<li><code>ByteBuffer</code> 的实现类内部，使用了Cleaner(虚引用)来监测 <code>ByteBuffer</code> 对象，<code>ByteBuffer</code> 对象被垃圾回收时会由 <code>ReferenecHandler</code> 后台线程通过<code>Cleaner.clean()</code>方法调用<code>Unsafe.freeMemory()</code>释放直接内存。</li>
</ul>
<blockquote>
<p>注意：<code>-XX:+DisableExplicitGC</code> 这个参数可以关闭 ”System.gc() 显式垃圾回收“ （在JVM调优会用），这样会导致以上分析的案例中，直接内存无法释放。</p>
<p>这种情况则需要自己主动通过 <code>unsafe.freeMemory(address);</code>来主动释放</p>
</blockquote>
<p>上面这么复杂的直接内存分配和释放，其实就是Unsafe的两个方法，为了更加直观理解底层，请看一下示例: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1G = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        <span class="keyword">long</span> base = unsafe.allocateMemory(_1G);</span><br><span class="line">        unsafe.setMemory(base,_1G,(<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"分配直接内存完毕"</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"开始释放直接内存"</span>);</span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不建议这么获取并使用Unsafe，这里只是为了演示测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe)f.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><p>Java 垃圾回收主要关注的是 <strong>堆内存</strong></p>
<h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收?"></a>1、如何判断对象可以回收?</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p>给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就可以垃圾回收，简单高效。</p>
<p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。所以Java虚拟机垃圾回收没有采用计数法。</p>
<p><img src="/images/java/jvm/循环引用.png" alt></p>
<h4 id="1-2-可达性分析法"><a href="#1-2-可达性分析法" class="headerlink" title="1.2 可达性分析法"></a>1.2 可达性分析法</h4><ul>
<li><p>Java虚拟机中垃圾回收器采用可达性分析法来探索所有存活的对象</p>
</li>
<li><p>扫描<strong>“堆”</strong>中的对象，看是否能够沿着 <code>GC Roots</code> 对象为起点的<strong>引用链接</strong>找到该对象，找不到表示可以回收。</p>
</li>
<li><p>那些对象可以作为 <code>GC Roots</code> ？<code>Menory Analyzer(MAT)</code> 这个软件可以帮助分析。</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
<p><img src="/images/java/jvm/GC_Roots.png" alt></p>
</li>
</ul>
<h4 id="1-3-四种引用（强、软、弱、虚）"><a href="#1-3-四种引用（强、软、弱、虚）" class="headerlink" title="1.3 四种引用（强、软、弱、虚）"></a>1.3 四种引用（强、软、弱、虚）</h4><blockquote>
<p>JDK1.2 以前，一个对象只有被引用和没有被引用两种状态。<br>后来，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p>
</blockquote>
<p><img src="/images/java/jvm/垃圾回收五种引用.png" alt></p>
<p><strong>强引用</strong></p>
<p>指在程序代码之中普遍存在的，类似<code>“Object obj = new Object()”</code>这类的引用。</p>
<p>特点：只有 <code>GC Root</code> <strong>全部都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象。</p>
<p>如上图：B、C对象都不引用A1对象时，A1对象才会被回收。</p>
<p><strong>软引用</strong></p>
<p>指还有用但并非必需的对象，内存不足会回收，类似<code>“SoftReference&lt;Object&gt; object = new SoftReference&lt;Object&gt;()”</code>这类的引用。</p>
<p>特点：仅有软引用引用该对象时，发生垃圾回收后，如果仍然内存不足会再次触发“垃圾回收”回收软引用对象。</p>
<p><img src="/images/java/jvm/垃圾回收软引用.png" alt></p>
<p>如上图：B对象 不再“强引用” A2对象，发生垃圾回收且内存不足时，G对象 “软引用”的 A2对象 就会被垃圾回收。</p>
<p><strong>弱引用</strong></p>
<p>和“软引用”很相似，区别在于：无论内存是否足够，都会被回收掉。类似<code>“WeakReference&lt;Object&gt; object = new WeakReference&lt;Object&gt;()”</code>这类的引用。</p>
<p>特点：发生垃圾回收时，无论内存是否充足，都会回收掉弱引用。</p>
<p><img src="/images/java/jvm/垃圾回收弱引用.png" alt></p>
<p>如上图: 如果 B对象 不再强引用 A3对象，只有C对象弱引用 A3对象，发生垃圾回收时，则A3对象会被回收。</p>
<p><strong>虚引用</strong></p>
<p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，由Reference Handler 线程调用虚引用相关发发是否内存。声明<code>“PhantomReference&lt;Object&gt;”</code> 。</p>
<p>虚引用的一个体现是<strong>释放“直接内存”所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存。</p>
<blockquote>
<p>虚引用是最弱的一种引用关系。 <strong>无法通过虚引用来取得一个对象实例</strong> 。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
</blockquote>
<p><strong>终结器引用</strong></p>
<p>所有的类都继承自Object类，Object类有一个finalize方法。当发生垃圾回收时，某个对象不再被<strong>其他的对象</strong>所引用时，会先将<strong>终结器引用</strong>对象放入<strong>引用队列</strong>中，然后根据<strong>终结器引用对象</strong>找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以在下一次垃圾回收发生时被回收。</p>
<p>特点：</p>
<p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队(被引用对象暂时没有被回收)，再由Finalizer线程通过终结器引用找到引用对象并调用它的finalize方法，下次GC时才能回收被引用对象。</p>
<blockquote>
<p>回收优先级低，不推荐使用终结器引用。</p>
</blockquote>
<p><img src="/images/java/jvm/垃圾回收终结器引用.png" alt></p>
<p>如上图：B对象不再引用A4对象。这时终结器引用对象就会被放入引用队列中（对象还没有被回收），引用队列会根据它，找到它所引用的对象A4，然后调用被引用对象的finalize方法，调用完成以后，该对象就可以在下次垃圾回收被回收。</p>
<p><strong>示例</strong></p>
<p>软引用示例：</p>
<p><img src="/images/java/jvm/软引用-示例代码.png" alt></p>
<p>清理软引用示例：</p>
<p><img src="/images/java/jvm/软引用清理-示例代码.png" alt></p>
<p>弱引用示例：</p>
<p><img src="/images/java/jvm/弱引用-示例代码.png" alt></p>
<h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h4><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间。</p>
<p><img src="/images/java/jvm/回收算法-标记.png" alt></p>
<p><strong>优点</strong>：速度快</p>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致JVM启动GC，一旦启动GC，我们的应用程序就会暂停，这就导致应用的响应速度变慢。</p>
<h4 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h4><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低。</p>
<p><strong>优点</strong>：不会有内存碎片</p>
<p><strong>缺点</strong>：速度慢</p>
<p><img src="/images/java/jvm/回收算法-标记整理.png" alt></p>
<h4 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h4><p>将内存分为大小相等的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。</p>
<p><strong>优点</strong>：不会有内存碎片</p>
<p><strong>缺点</strong>：需要占用双倍内存空间</p>
<p><img src="/images/java/jvm/回收算法-复制-标记垃圾内存.png" alt></p>
<p><img src="/images/java/jvm/回收算法-复制-移动有用对象到TO区.png" alt></p>
<p><img src="/images/java/jvm/回收算法-复制-清空FROM区的垃圾.png" alt></p>
<p><img src="/images/java/jvm/回收算法-交换FROM-TO区.png" alt></p>
<h3 id="3、分代垃圾回收"><a href="#3、分代垃圾回收" class="headerlink" title="3、分代垃圾回收"></a>3、分代垃圾回收</h3><p>分为两大区：新生代和老年代。需长期存活的对象会存放在老年代区，很少发生垃圾回收；在新生代，垃圾回收发生频繁，处理生命周期比较短的对象。新生代也细分为三个区：</p>
<ul>
<li>新生代<ul>
<li>伊甸园（Eden）</li>
<li>幸存区（Survivor）From</li>
<li>幸存区（Survivor）To</li>
</ul>
</li>
<li>老年代</li>
</ul>
<p><img src="/images/java/jvm/分代回收.png" alt></p>
<blockquote>
<p>新生代区发生的垃圾回收称为：Minor GC</p>
</blockquote>
<ul>
<li>新创建的对象默认存放在Eden区</li>
<li>当Eden区内存不足，会触发垃圾回收 <code>Minor GC</code> ，存活的对象会复制到 “幸存区To”。存活对象寿命加1，再交换幸存区（From - To）。</li>
<li><code>Minor GC</code> 会引发 <code>stop the world</code> ，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行。</li>
<li>当Eden区再次内存不足，再触发垃圾回收 <code>Minor GC</code> ，Eden区存活对象复制到 “幸存区To”，并且回收 “幸存区From”，“幸存区From”存活对象也复制到“幸存区To”。存活对象寿命加1（原来“幸存区From”存活对象这时候寿命是 2 了），再交换幸存区（From - To）。</li>
<li>如果幸存区中的对象的<strong>寿命超过阈值</strong>，会晋升老年代，最大寿命是15(4bit）。</li>
<li>新生代和老年代中的内存都满了，就会先尝试触发 <code>Minor GC</code> ，如果空间扔不足，再触发<code>Full GC</code>， <code>stop the world</code> 时间更长。</li>
</ul>
<p><img src="/images/java/jvm/分代回收VM参数.png" alt></p>
<h4 id="GC分析总结"><a href="#GC分析总结" class="headerlink" title="GC分析总结"></a>GC分析总结</h4><ul>
<li><p><strong>大对象处理策略</strong></p>
<p>当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代</p>
</li>
<li><p><strong>线程内存溢出</strong></p>
<p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行<br>这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常。</p>
</li>
</ul>
<h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><blockquote>
<p>STW: Stop The World，<code>Minor GC</code> 会引发 Stop The World ，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行。</p>
</blockquote>
<p>三种垃圾回收器概述和特点比较：</p>
<ul>
<li>串行<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
</ul>
</li>
<li>吞吐量优先<ul>
<li>多线程</li>
<li>堆内存较大，多个CPU</li>
<li>让单位时间内，总的STW时间最短，如2次GC： 0.2 + 0.2 = 0.4</li>
</ul>
</li>
<li>响应时间优先<ul>
<li>多线程</li>
<li>堆内存较大，多个CPU</li>
<li>尽可能让单次STW的时间最短，如5次GC： 0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</li>
</ul>
</li>
</ul>
<h4 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h4><p><img src="/images/java/jvm/垃圾回收器-串行.png" alt></p>
<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态。</p>
<h4 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h4><p>并行执行，会暂停用户线程。</p>
<p><img src="/images/java/jvm/垃圾回收器-吞吐量优先.png" alt></p>
<h4 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先"></a>4.3 响应时间优先</h4><p>并发执行，不暂停用户线程，和用户线程并发执行（与用户线程抢CPU）。</p>
<p>基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片。</p>
<p><img src="/images/java/jvm/垃圾回收器-响应时间优先.png" alt></p>
<h4 id="4-4-G1-（Garbage-First）"><a href="#4-4-G1-（Garbage-First）" class="headerlink" title="4.4 G1 （Garbage First）"></a>4.4 G1 （Garbage First）</h4><p>G1是一个垃圾回收器， <strong>JDK7</strong> 由官方支持， <strong>JDK9</strong> 开始被默认使用的垃圾回收器（废弃了CMS垃圾回收器），适用场景：</p>
<ul>
<li>同时注重吞吐量（Throughput）和低延迟（Low latency）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个 <strong>大小相等</strong> 的区域（Region）</li>
<li>整体上是 <strong>标记+整理</strong> 算法，两个区域（Region）之间是 <strong>复制</strong> 算法</li>
</ul>
<p>相关的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC                  //开关，JDK8要手动开启</span><br><span class="line">-XX:G1HeapRegionSize=size</span><br><span class="line">-XX:MaxGCPauseMillis=time     //默认200ms</span><br></pre></td></tr></table></figure>
<h5 id="4-4-1-G1垃圾回收阶段"><a href="#4-4-1-G1垃圾回收阶段" class="headerlink" title="4.4.1 G1垃圾回收阶段"></a>4.4.1 G1垃圾回收阶段</h5><p>这是一个循环的过程</p>
<p><img src="/images/java/jvm/G1_新生代.png" alt></p>
<h5 id="4-4-2-G1-Young-Collection"><a href="#4-4-2-G1-Young-Collection" class="headerlink" title="4.4.2 G1 Young Collection"></a>4.4.2 G1 Young Collection</h5><p>会STW</p>
<blockquote>
<p>E: 伊甸园区</p>
<p>S: 幸存区</p>
<p>O: 老年代</p>
</blockquote>
<p>新生代伊甸园区</p>
<p><img src="/images/java/jvm/G1_YoungCollection_1.png" alt></p>
<p>新生代垃圾回收：幸存对象 -&gt; 复制算法 -&gt; 幸存区</p>
<p><img src="/images/java/jvm/G1_YoungCollection_2.png" alt></p>
<p>新生代垃圾回收：幸存区大龄对象 -&gt; 复制算法 -&gt; 老年代</p>
<p><img src="/images/java/jvm/G1_YoungCollection_3.png" alt></p>
<h5 id="4-4-3-G1-Young-Collection-CM-并发标记"><a href="#4-4-3-G1-Young-Collection-CM-并发标记" class="headerlink" title="4.4.3 G1 Young Collection + CM(并发标记)"></a>4.4.3 G1 Young Collection + CM(并发标记)</h5><ul>
<li>在 Young GC 时会对 <strong>GC Root</strong> 进行初始标记</li>
<li>在老年代占用 <strong>堆内存的比例</strong> 达到阈值时，对进行并发标记（不会STW），由参数 <code>-XX:InitiatingHeapOccupancyPercent=percent(默认45%)</code></li>
</ul>
<p><img src="/images/java/jvm/G1_YoungCollection_CM.png" alt></p>
<h5 id="4-4-4-G1-Mixed-Collection-混合回收"><a href="#4-4-4-G1-Mixed-Collection-混合回收" class="headerlink" title="4.4.4 G1 Mixed Collection (混合回收)"></a>4.4.4 G1 Mixed Collection (混合回收)</h5><p> 会对 <code>E</code> <code>S</code> <code>O</code> 进行<strong>全面的垃圾回收</strong></p>
<ul>
<li>最终标记 (Remark) 会STW</li>
<li>拷贝存活 (Evacuation) 会STW</li>
</ul>
<p><code>-XX:MaxGCPauseMills:ms</code>  用于指定最长的停顿时间</p>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p>
<p><img src="/images/java/jvm/G1_YoungCollection_MIXED.png" alt></p>
<h5 id="4-4-5-Full-GC"><a href="#4-4-5-Full-GC" class="headerlink" title="4.4.5  Full GC"></a>4.4.5  Full GC</h5><ul>
<li>SerialGC<ul>
<li>新生代内存不足发生的垃圾回收 – minor gc</li>
<li>老年代内存不足发生的垃圾回收 – Full GC</li>
</ul>
</li>
<li>ParallelGC<ul>
<li>新生代内存不足发生的垃圾回收 – minor gc</li>
<li>老年代内存不足发生的垃圾回收 – Full GC</li>
</ul>
</li>
<li>CMS<ul>
<li>新生代内存不足发生的垃圾回收 – minor gc</li>
<li>老年代内存不足</li>
</ul>
</li>
<li>G1<ul>
<li>新生代内存不足发生的垃圾回收 – minor gc</li>
<li>老年代内存不足（老年代所占内存超过阈值）<ul>
<li><strong>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</strong></li>
<li><strong>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-4-6-G1-Young-Collection-跨代引用"><a href="#4-4-6-G1-Young-Collection-跨代引用" class="headerlink" title="4.4.6  G1 Young Collection 跨代引用"></a>4.4.6  G1 Young Collection 跨代引用</h5><p>新生代回收的跨代引用（老年代引用新生代）问题</p>
<blockquote>
<p><strong>老年代</strong>区细分为多个<strong>卡表</strong>，如果某卡表中有对象引用了<strong>新生代</strong>的对象，那么这块区域标记为 <strong>脏卡</strong>。</p>
</blockquote>
<ul>
<li>卡表与Remembered Set<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
</ul>
</li>
</ul>
</li>
<li>在引用变更时通过post-write barried + dirty card queue  （更新指令先放入脏卡队列）</li>
<li>concurrent refinement threads  更新 Remembered Set （由一个线程完成更新脏卡的操作）</li>
</ul>
<p><img src="/images/java/jvm/脏卡0.png" alt></p>
<p><img src="/images/java/jvm/脏卡2.png" alt></p>
<h5 id="4-4-7-G1-Remark-（重新标记）"><a href="#4-4-7-G1-Remark-（重新标记）" class="headerlink" title="4.4.7  G1 Remark （重新标记）"></a>4.4.7  G1 Remark （重新标记）</h5><blockquote>
<p>黑色：已被处理，需要保留的  </p>
<p>灰色：正在处理中的 </p>
<p>白色：还未处理的</p>
</blockquote>
<p>并发阶段标记时处理示例图：</p>
<p><img src="/images/java/jvm/remark_0.png" alt></p>
<p>并发下，下图中对C对象的处理可能受到用户线程的影响，比如：</p>
<p>标记前，“B对象”对“C对象”的引用被用户线程删除，这时“C对象”没有引用被标记为白色（垃圾），但标记尚未完成，“C对象”又被用户线程作为“A对象”的引用，但“C对象”已经被误标记为垃圾。</p>
<p>这种问题就要通过remark来解决。</p>
<p><img src="/images/java/jvm/remark_1.png" alt></p>
<p>重新标记阶段处理示意图：</p>
<p><img src="/images/java/jvm/remark_2.png" alt></p>
<ul>
<li>当引用发生改变时，JVM给它加入一个写屏障</li>
<li>当A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，指令执行的操作是将C放入一个队列（satb_mark_queue）当中，并将C变为 “处理中” 灰色状态</li>
<li>在并发标记阶段结束以后，进入重新标记阶段（会STW），然后将放在该队列中的对象重新处理，发现有强引用引用它，就不会垃圾回收它。</li>
</ul>
<h5 id="4-4-8-JDK-8u20字符串去重"><a href="#4-4-8-JDK-8u20字符串去重" class="headerlink" title="4.4.8  JDK 8u20字符串去重"></a>4.4.8  JDK 8u20字符串去重</h5><p>优点与缺点</p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<p>字符串去重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开关</span></span><br><span class="line">-XX:+UseStringDeduplication</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同的对象，使用的是同一个char数组</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">// char[]&#123;'h','e','l','l','o'&#125;</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">// char[]&#123;'h','e','l','l','o'&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当<strong>新生代</strong>回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>注意，其与 <code>String.intern()</code> 的区别<ul>
<li><code>String.intern()</code>关注的是字符串对象</li>
<li>“字符串去重”关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h5 id="4-4-9-JDK-8u40-并发标记类卸载"><a href="#4-4-9-JDK-8u40-并发标记类卸载" class="headerlink" title="4.4.9 JDK 8u40 并发标记类卸载"></a>4.4.9 JDK 8u40 并发标记类卸载</h5><p> JDK 8u40在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类。</p>
<p>开关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ClassUnloadingWithConcurrentMark 默认启用</span><br></pre></td></tr></table></figure>
<h5 id="4-4-10-JDK-8u60回收巨型对象"><a href="#4-4-10-JDK-8u60回收巨型对象" class="headerlink" title="4.4.10 JDK 8u60回收巨型对象"></a>4.4.10 JDK 8u60回收巨型对象</h5><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在<strong>新生代</strong>垃圾回收时处理掉</li>
</ul>
<p><img src="/images/java/jvm/巨型对象0.png" alt></p>
<p><img src="/images/java/jvm/巨型对象1.png" alt></p>
<h5 id="4-4-11-JDK-9并发标记起始时间的调整"><a href="#4-4-11-JDK-9并发标记起始时间的调整" class="headerlink" title="4.4.11 JDK 9并发标记起始时间的调整"></a>4.4.11 JDK 9并发标记起始时间的调整</h5><ul>
<li>并发标记必须在堆空间占满前完成，否则退化为Full GC</li>
<li>JDK9之前，需要使用 <code>-XX:InitatingHeapOccupancyPercent</code> 指定比例</li>
<li>JDK9可以动态调整此值<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置初始值</li>
<li>JVM进行数据采样并动态调整</li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<h3 id="5、GC-垃圾回收-调优"><a href="#5、GC-垃圾回收-调优" class="headerlink" title="5、GC(垃圾回收)调优"></a>5、GC(垃圾回收)调优</h3><p>调优跟应用、环境等因素有关，需要根据经验做出调整。</p>
<p>查看Java虚拟机调优参数命令，具体命令可以看官网的文档说明。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | findstr "GC"</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">❯ java <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findstr <span class="string">"GC"</span></span><br><span class="line">java version <span class="string">"11.0.1"</span> <span class="number">2018</span><span class="literal">-10</span><span class="literal">-16</span> LTS</span><br><span class="line">Java(TM) SE Runtime Environment <span class="number">18.9</span> (build <span class="number">11.0</span>.<span class="number">1</span>+<span class="number">13</span><span class="literal">-LTS</span>)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span><span class="literal">-Bit</span> Server VM <span class="number">18.9</span> (build <span class="number">11.0</span>.<span class="number">1</span>+<span class="number">13</span><span class="literal">-LTS</span>, mixed mode)</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale        = <span class="number">10</span>                                        &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool BindGCTaskThreadsToCPUs                  = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     uint ConcGCThreads                            = <span class="number">1</span>                                         &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">     bool DisableExplicitGC                        = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool ExplicitGCInvokesConcurrent              = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx G1MixedGCCountTarget                     = <span class="number">8</span>                                         &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx GCDrainStackTargetSize                   = <span class="number">64</span>                                        &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">    uintx GCHeapFreeLimit                          = <span class="number">2</span>                                         &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx GCLockerEdenExpansionPercent             = <span class="number">5</span>                                         &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool GCLockerInvokesConcurrent                = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx GCPauseIntervalMillis                    = <span class="number">201</span>                                       &#123;product&#125; &#123;default&#125;</span><br><span class="line">     uint GCTaskTimeStampEntries                   = <span class="number">200</span>                                       &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx GCTimeLimit                              = <span class="number">98</span>                                        &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx GCTimeRatio                              = <span class="number">12</span>                                        &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpAfterFullGC                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpBeforeFullGC                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">   size_t HeapSizePerGCThread                      = <span class="number">43620760</span>                                  &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx MaxGCMinorPauseMillis                    = <span class="number">18446744073709551615</span>                      &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx MaxGCPauseMillis                         = <span class="number">200</span>                                       &#123;product&#125; &#123;default&#125;</span><br><span class="line">      int ParGCArrayScanChunk                      = <span class="number">50</span>                                        &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx ParGCDesiredObjsFromOverflowList         = <span class="number">20</span>                                        &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool ParGCTrimOverflow                        = true                                      &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool ParGCUseLocalOverflow                    = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">    uintx ParallelGCBufferWastePct                 = <span class="number">10</span>                                        &#123;product&#125; &#123;default&#125;</span><br><span class="line">     uint ParallelGCThreads                        = <span class="number">4</span>                                         &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool PrintGC                                  = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool PrintGCDetails                           = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool ScavengeBeforeFullGC                     = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseAdaptiveGCBoundary                    = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseAdaptiveSizeDecayMajorGCCost          = true                                      &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseAdaptiveSizePolicyWithSystemGC        = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseConcMarkSweepGC                       = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseDynamicNumberOfGCThreads              = true                                      &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseG1GC                                  = true                                      &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">     bool UseGCOverheadLimit                       = true                                      &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseGCTaskAffinity                        = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseMaximumCompactionOnSystemGC           = true                                      &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseParallelGC                            = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseParallelOldGC                         = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     bool UseSerialGC                              = false                                     &#123;product&#125; &#123;default&#125;</span><br><span class="line">     </span><br><span class="line">----------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> <span class="string">"C:\Program Files\Java\jdk1.8.0_25\bin\java"</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findstr <span class="string">"GC"</span></span><br><span class="line">java version <span class="string">"1.8.0_181"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_181<span class="literal">-b13</span>)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span><span class="literal">-Bit</span> Server VM (build <span class="number">25.181</span><span class="literal">-b13</span>, mixed mode)</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = <span class="number">10</span>                                  &#123;product&#125;</span><br><span class="line">    uintx AutoGCSelectPauseMillis                   = <span class="number">5000</span>                                &#123;product&#125;</span><br><span class="line">     bool BindGCTaskThreadsToCPUs                   = false                               &#123;product&#125;</span><br><span class="line">    uintx CMSFullGCsBeforeCompaction                = <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    uintx ConcGCThreads                             = <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">     bool DisableExplicitGC                         = false                               &#123;product&#125;</span><br><span class="line">     bool ExplicitGCInvokesConcurrent               = false                               &#123;product&#125;</span><br><span class="line">     bool ExplicitGCInvokesConcurrentAndUnloadsClasses  = false                               &#123;product&#125;</span><br><span class="line">    uintx G1MixedGCCountTarget                      = <span class="number">8</span>                                   &#123;product&#125;</span><br><span class="line">    uintx GCDrainStackTargetSize                    = <span class="number">64</span>                                  &#123;product&#125;</span><br><span class="line">    uintx GCHeapFreeLimit                           = <span class="number">2</span>                                   &#123;product&#125;</span><br><span class="line">    uintx GCLockerEdenExpansionPercent              = <span class="number">5</span>                                   &#123;product&#125;</span><br><span class="line">     bool GCLockerInvokesConcurrent                 = false                               &#123;product&#125;</span><br><span class="line">    uintx GCLogFileSize                             = <span class="number">8192</span>                                &#123;product&#125;</span><br><span class="line">    uintx GCPauseIntervalMillis                     = <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    uintx GCTaskTimeStampEntries                    = <span class="number">200</span>                                 &#123;product&#125;</span><br><span class="line">    uintx GCTimeLimit                               = <span class="number">98</span>                                  &#123;product&#125;</span><br><span class="line">    uintx GCTimeRatio                               = <span class="number">99</span>                                  &#123;product&#125;</span><br><span class="line">     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;</span><br><span class="line">     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;</span><br><span class="line">    uintx HeapSizePerGCThread                       = <span class="number">87241520</span>                            &#123;product&#125;</span><br><span class="line">    uintx MaxGCMinorPauseMillis                     = <span class="number">4294967295</span>                          &#123;product&#125;</span><br><span class="line">    uintx MaxGCPauseMillis                          = <span class="number">4294967295</span>                          &#123;product&#125;</span><br><span class="line">    uintx NumberOfGCLogFiles                        = <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">     intx ParGCArrayScanChunk                       = <span class="number">50</span>                                  &#123;product&#125;</span><br><span class="line">    uintx ParGCDesiredObjsFromOverflowList          = <span class="number">20</span>                                  &#123;product&#125;</span><br><span class="line">     bool ParGCTrimOverflow                         = true                                &#123;product&#125;</span><br><span class="line">     bool ParGCUseLocalOverflow                     = false                               &#123;product&#125;</span><br><span class="line">    uintx ParallelGCBufferWastePct                  = <span class="number">10</span>                                  &#123;product&#125;</span><br><span class="line">    uintx ParallelGCThreads                         = <span class="number">4</span>                                   &#123;product&#125;</span><br><span class="line">     bool ParallelGCVerbose                         = false                               &#123;product&#125;</span><br><span class="line">     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGC                                   = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGCApplicationConcurrentTime          = false                               &#123;product&#125;</span><br><span class="line">     bool PrintGCApplicationStoppedTime             = false                               &#123;product&#125;</span><br><span class="line">     bool PrintGCCause                              = true                                &#123;product&#125;</span><br><span class="line">     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGCDetails                            = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGCID                                 = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGCTaskTimeStamps                     = false                               &#123;product&#125;</span><br><span class="line">     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintHeapAtGC                             = false                               &#123;product rw&#125;</span><br><span class="line">     bool PrintHeapAtGCExtended                     = false                               &#123;product rw&#125;</span><br><span class="line">     bool PrintJNIGCStalls                          = false                               &#123;product&#125;</span><br><span class="line">     bool PrintParallelOldGCPhaseTimes              = false                               &#123;product&#125;</span><br><span class="line">     bool PrintReferenceGC                          = false                               &#123;product&#125;</span><br><span class="line">     bool ScavengeBeforeFullGC                      = true                                &#123;product&#125;</span><br><span class="line">     bool TraceDynamicGCThreads                     = false                               &#123;product&#125;</span><br><span class="line">     bool TraceParallelOldGCTasks                   = false                               &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveGCBoundary                     = false                               &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizeDecayMajorGCCost           = true                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizePolicyWithSystemGC         = false                               &#123;product&#125;</span><br><span class="line">     bool UseAutoGCSelectPolicy                     = false                               &#123;product&#125;</span><br><span class="line">     bool UseConcMarkSweepGC                        = false                               &#123;product&#125;</span><br><span class="line">     bool UseDynamicNumberOfGCThreads               = false                               &#123;product&#125;</span><br><span class="line">     bool UseG1GC                                   = false                               &#123;product&#125;</span><br><span class="line">     bool UseGCLogFileRotation                      = false                               &#123;product&#125;</span><br><span class="line">     bool UseGCOverheadLimit                        = true                                &#123;product&#125;</span><br><span class="line">     bool UseGCTaskAffinity                         = false                               &#123;product&#125;</span><br><span class="line">     bool UseMaximumCompactionOnSystemGC            = true                                &#123;product&#125;</span><br><span class="line">     bool UseParNewGC                               = false                               &#123;product&#125;</span><br><span class="line">     bool UseParallelGC                            := true                                &#123;product&#125;</span><br><span class="line">     bool UseParallelOldGC                          = true                                &#123;product&#125;</span><br><span class="line">     bool UseSerialGC                               = false                               &#123;product&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h4><p>应用需要【低延迟】还是【高吞吐量】？情景举例：</p>
<ul>
<li>示例1：科学运算应用追求【高吞吐量】，延迟时间影响不大，可以选择【高吞吐量】垃圾回收器ParallelGC。</li>
<li><p>示例2：互联网应用需要更快的响应时间，可以选择【低延迟】垃圾回收器。</p>
<p>选择合适的回收器：</p>
</li>
<li><p>【低延迟】垃圾回收器：CMS G1 ZGC </p>
</li>
<li><p>【高吞吐量】垃圾回收器：ParallelGC </p>
</li>
<li>Zing GC 回收器自称零STW，可管理超大内存</li>
</ul>
<h4 id="5-3-最好的GC是不发生GC"><a href="#5-3-最好的GC是不发生GC" class="headerlink" title="5.3 最好的GC是不发生GC"></a>5.3 最好的GC是不发生GC</h4><p>如果经常发生Full GC，首先应该检查代码问题，比如：查数据库把整张表的数据都拿出来了。</p>
<p>查看Full GC前后的内存占用，考虑以下几个问题</p>
<ul>
<li>数据是不是太多？（select * from big_tables）</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏<ul>
<li>static Map map = new HashMap()作为缓存 </li>
<li>一直往map防止对象而不移除，越积越多</li>
<li>可以用软、弱引用解决</li>
<li>或者Redis等第三方软件作为缓存</li>
</ul>
</li>
</ul>
<h4 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优"></a>5.4 新生代调优</h4><p>新生代的特点</p>
<ul>
<li>所有的new操作分配内存都是非常廉价的<ul>
<li>TLAB： thread-local allocation buffer (线程局部分配缓冲区)</li>
<li>TLAB的作用是让每个线程用私有的伊甸园区来分配new对象内存</li>
</ul>
</li>
<li>死亡对象回收零代价</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>Minor GC 所用时间远远小于 Full GC</li>
</ul>
<p>新生代内存越大越好么？答案：不是！</p>
<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
</ul>
<p>新生代调优： </p>
<ul>
<li>Oracle建议新生代内存占<strong>堆大小</strong>的 25% ~ 50% ，<code>-Xmn</code> 参数设置新生代大小。</li>
<li>老师推荐：容纳所有【并发量 * ( 请求 - 响应 ) 】的数据为宜</li>
</ul>
<p>幸存区调优：</p>
<ul>
<li>幸存区大到能够保留【当前活跃对象 + 需要晋升的对象】 </li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul>
<h4 id="5-5-老年代调优"><a href="#5-5-老年代调优" class="headerlink" title="5.5 老年代调优"></a>5.5 老年代调优</h4><p>以CMS为例：</p>
<ul>
<li>CMS的老年代内存越大越好</li>
<li>先尝试不用调优，如果没有FullGC则不需要调优，有FullGC也先调优新生代</li>
<li>观察FullGC时老年代内存占用，调大老年代预设值 1/4 ~ 1/3 </li>
</ul>
<h4 id="5-6-案例分析"><a href="#5-6-案例分析" class="headerlink" title="5.6 案例分析"></a>5.6 案例分析</h4><p>还是看视频吧</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/jvm/" rel="tag"># jvm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Linux/Ubuntu 18.04配置静态IP/" rel="next" title="Ubuntu 18.04~20.04配置静态IP">
                <i class="fa fa-chevron-left"></i> Ubuntu 18.04~20.04配置静态IP
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Java/黑马程序员JVM类加载与字节码笔记/" rel="prev" title="黑马程序员JVM类加载与字节码笔记">
                黑马程序员JVM类加载与字节码笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/custom/avatar_samwen.jpg" alt="KevinWen">
            
              <p class="site-author-name" itemprop="name">KevinWen</p>
              <p class="site-description motion-element" itemprop="description">做人如果没有梦想,和咸鱼有什么区别呢?</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">293</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">85</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/kevinvane" title="GitHub &rarr; https://github.com/kevinvane" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="/kevinvane@gmail.com" title="E-Mail &rarr; kevinvane@gmail.com"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://weibo.com/kevinvane" title="Weibo &rarr; https://weibo.com/kevinvane" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://plus.google.com/kevinvane" title="Google &rarr; https://plus.google.com/kevinvane" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://twitter.com/kevinvane" title="Twitter &rarr; https://twitter.com/kevinvane" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、什么是JVM"><span class="nav-number">1.</span> <span class="nav-text">一、什么是JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#好处"><span class="nav-number">1.2.</span> <span class="nav-text">好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较"><span class="nav-number">1.3.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见JVM"><span class="nav-number">1.4.</span> <span class="nav-text">常见JVM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、内存结构"><span class="nav-number">2.</span> <span class="nav-text">二、内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、程序计数器"><span class="nav-number">2.1.</span> <span class="nav-text">1、程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、虚拟机栈"><span class="nav-number">2.2.</span> <span class="nav-text">2、虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-定义"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-内存溢出"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-线程运行诊断"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3 线程运行诊断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、本地方法栈"><span class="nav-number">2.3.</span> <span class="nav-text">3、本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、堆-Heap"><span class="nav-number">2.4.</span> <span class="nav-text">4、堆(Heap)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-堆内存溢出"><span class="nav-number">2.4.1.</span> <span class="nav-text">4.1 堆内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-堆内存诊断"><span class="nav-number">2.4.2.</span> <span class="nav-text">4.2 堆内存诊断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、方法区"><span class="nav-number">2.5.</span> <span class="nav-text">5、方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-内存溢出"><span class="nav-number">2.5.1.</span> <span class="nav-text">5.1 内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-常量池"><span class="nav-number">2.5.2.</span> <span class="nav-text">5.2 常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-运行时常量池"><span class="nav-number">2.5.3.</span> <span class="nav-text">5.3 运行时常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-串池-StringTable"><span class="nav-number">2.5.4.</span> <span class="nav-text">5.4 串池(StringTable)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-1-StringTable的特性："><span class="nav-number">2.5.4.1.</span> <span class="nav-text">5.4.1 StringTable的特性：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#StringTable示例1："><span class="nav-number">2.5.4.1.1.</span> <span class="nav-text">StringTable示例1：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#StringTable示例2："><span class="nav-number">2.5.4.1.2.</span> <span class="nav-text">StringTable示例2：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#StringTable示例3："><span class="nav-number">2.5.4.1.3.</span> <span class="nav-text">StringTable示例3：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-2-intern方法"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">5.4.2 intern方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-3-StringTable的位置"><span class="nav-number">2.5.4.3.</span> <span class="nav-text">5.4.3  StringTable的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-4-StringTable垃圾回收"><span class="nav-number">2.5.4.4.</span> <span class="nav-text">5.4.4 StringTable垃圾回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-5-StringTable调优"><span class="nav-number">2.5.4.5.</span> <span class="nav-text">5.4.5 StringTable调优</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、直接内存"><span class="nav-number">2.6.</span> <span class="nav-text">6、直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、垃圾回收"><span class="nav-number">3.</span> <span class="nav-text">三、垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、如何判断对象可以回收"><span class="nav-number">3.1.</span> <span class="nav-text">1、如何判断对象可以回收?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-引用计数法"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1 引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-可达性分析法"><span class="nav-number">3.1.2.</span> <span class="nav-text">1.2 可达性分析法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-四种引用（强、软、弱、虚）"><span class="nav-number">3.1.3.</span> <span class="nav-text">1.3 四种引用（强、软、弱、虚）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、垃圾回收算法"><span class="nav-number">3.2.</span> <span class="nav-text">2、垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-标记清除"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 标记清除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-标记整理"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 标记整理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-复制"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.3 复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、分代垃圾回收"><span class="nav-number">3.3.</span> <span class="nav-text">3、分代垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC分析总结"><span class="nav-number">3.3.1.</span> <span class="nav-text">GC分析总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、垃圾回收器"><span class="nav-number">3.4.</span> <span class="nav-text">4、垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-串行"><span class="nav-number">3.4.1.</span> <span class="nav-text">4.1 串行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-吞吐量优先"><span class="nav-number">3.4.2.</span> <span class="nav-text">4.2 吞吐量优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-响应时间优先"><span class="nav-number">3.4.3.</span> <span class="nav-text">4.3 响应时间优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-G1-（Garbage-First）"><span class="nav-number">3.4.4.</span> <span class="nav-text">4.4 G1 （Garbage First）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-1-G1垃圾回收阶段"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">4.4.1 G1垃圾回收阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-G1-Young-Collection"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">4.4.2 G1 Young Collection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-3-G1-Young-Collection-CM-并发标记"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">4.4.3 G1 Young Collection + CM(并发标记)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-4-G1-Mixed-Collection-混合回收"><span class="nav-number">3.4.4.4.</span> <span class="nav-text">4.4.4 G1 Mixed Collection (混合回收)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-5-Full-GC"><span class="nav-number">3.4.4.5.</span> <span class="nav-text">4.4.5  Full GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-6-G1-Young-Collection-跨代引用"><span class="nav-number">3.4.4.6.</span> <span class="nav-text">4.4.6  G1 Young Collection 跨代引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-7-G1-Remark-（重新标记）"><span class="nav-number">3.4.4.7.</span> <span class="nav-text">4.4.7  G1 Remark （重新标记）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-8-JDK-8u20字符串去重"><span class="nav-number">3.4.4.8.</span> <span class="nav-text">4.4.8  JDK 8u20字符串去重</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-9-JDK-8u40-并发标记类卸载"><span class="nav-number">3.4.4.9.</span> <span class="nav-text">4.4.9 JDK 8u40 并发标记类卸载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-10-JDK-8u60回收巨型对象"><span class="nav-number">3.4.4.10.</span> <span class="nav-text">4.4.10 JDK 8u60回收巨型对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-11-JDK-9并发标记起始时间的调整"><span class="nav-number">3.4.4.11.</span> <span class="nav-text">4.4.11 JDK 9并发标记起始时间的调整</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、GC-垃圾回收-调优"><span class="nav-number">3.5.</span> <span class="nav-text">5、GC(垃圾回收)调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-调优领域"><span class="nav-number">3.5.1.</span> <span class="nav-text">5.1 调优领域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-确定目标"><span class="nav-number">3.5.2.</span> <span class="nav-text">5.2 确定目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-最好的GC是不发生GC"><span class="nav-number">3.5.3.</span> <span class="nav-text">5.3 最好的GC是不发生GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-新生代调优"><span class="nav-number">3.5.4.</span> <span class="nav-text">5.4 新生代调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-老年代调优"><span class="nav-number">3.5.5.</span> <span class="nav-text">5.5 老年代调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-案例分析"><span class="nav-number">3.5.6.</span> <span class="nav-text">5.6 案例分析</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KevinWen</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

</body>
</html>
