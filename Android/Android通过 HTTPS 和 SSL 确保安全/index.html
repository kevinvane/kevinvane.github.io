<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/custom/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/custom/favicon.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="摘录: https:&#x2F;&#x2F;developer.android.google.cn&#x2F;training&#x2F;articles&#x2F;security-ssl  安全套接字层 (SSL)（现在技术上称为传输层安全协议 (TLS)）是一个通用构建块，用于在客户端与服务器之间进行加密通信。应用很可能以错误的方式使用 SSL，从而导致恶意实体能够拦截网络上的应用数据。为了帮助您确保您的应用不会出现这种情况，本文重点介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="Android通过 HTTPS 和 SSL 确保安全.md">
<meta property="og:url" content="http://yoursite.com/Android/Android%E9%80%9A%E8%BF%87%20HTTPS%20%E5%92%8C%20SSL%20%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8/index.html">
<meta property="og:site_name" content="咸鱼">
<meta property="og:description" content="摘录: https:&#x2F;&#x2F;developer.android.google.cn&#x2F;training&#x2F;articles&#x2F;security-ssl  安全套接字层 (SSL)（现在技术上称为传输层安全协议 (TLS)）是一个通用构建块，用于在客户端与服务器之间进行加密通信。应用很可能以错误的方式使用 SSL，从而导致恶意实体能够拦截网络上的应用数据。为了帮助您确保您的应用不会出现这种情况，本文重点介绍">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-04-27T11:52:36.000Z">
<meta property="article:modified_time" content="2021-12-28T03:24:10.115Z">
<meta property="article:author" content="KevinWen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/Android/Android%E9%80%9A%E8%BF%87%20HTTPS%20%E5%92%8C%20SSL%20%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android通过 HTTPS 和 SSL 确保安全.md | 咸鱼</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">咸鱼</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">咸鱼是以盐腌渍后，晒干的鱼</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-git">

    <a href="/git-help/" rel="section"><i class="fa fa-fw fa-code"></i>Git</a>

  </li>
        <li class="menu-item menu-item-android-&-jdk">

    <a href="/jdk-features/" rel="section"><i class="fa fa-fw fa-archive"></i>Android & JDK</a>

  </li>
        <li class="menu-item menu-item-java资源">

    <a href="/awesome-java/" rel="section"><i class="fa fa-fw fa-code"></i>Java资源</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-hexo">

    <a href="/hexo/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>hexo</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Android/Android%E9%80%9A%E8%BF%87%20HTTPS%20%E5%92%8C%20SSL%20%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom/avatar_samwen.jpg">
      <meta itemprop="name" content="KevinWen">
      <meta itemprop="description" content="做人如果没有梦想,和咸鱼有什么区别呢?">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咸鱼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android通过 HTTPS 和 SSL 确保安全.md
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-27 19:52:36" itemprop="dateCreated datePublished" datetime="2018-04-27T19:52:36+08:00">2018-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-28 11:24:10" itemprop="dateModified" datetime="2021-12-28T11:24:10+08:00">2021-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>摘录: <a target="_blank" rel="noopener" href="https://developer.android.google.cn/training/articles/security-ssl">https://developer.android.google.cn/training/articles/security-ssl</a></p>
</blockquote>
<p>安全套接字层 (SSL)（现在技术上称为传输层安全协议 (TLS)）是一个通用构建块，用于在客户端与服务器之间进行加密通信。应用很可能以错误的方式使用 SSL，从而导致恶意实体能够拦截网络上的应用数据。为了帮助您确保您的应用不会出现这种情况，本文重点介绍了使用安全网络协议的常见陷阱，并解决对使用公钥基础结构 (PKI) 关注较多的问题。 </p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>在典型的 SSL 使用场景中，会使用一个包含公钥及与其匹配的私钥的证书配置服务器。作为 SSL 客户端与服务器握手的一部分，服务器将通过使用公钥加密签署其证书来证明自己具有私钥。</p>
<p>不过，任何人都可以生成他们自己的证书和私钥，因此，一个简单的握手只能说明服务器知道与证书公钥匹配的私钥，除此之外什么都证明不了。解决此问题的一个方法是让客户端拥有其信任的一个或多个证书集。如果证书不在此集合中，则不会信任服务器。</p>
<p>但这个简单的方法有几个缺点。服务器应能够随时间的推移升级到更强的密钥（“密钥旋转”），使用新的公钥替换证书中的公钥。遗憾的是，客户端应用现在必须根据服务器配置发生的变化进行更新。如果服务器不在应用开发者的控制下（例如，如果服务器是一个第三方网络服务），则很容易出现问题。如果应用必须与网络浏览器或电子邮件应用等任意服务器通信，那么，此方法也会带来问题。</p>
<p>为弥补这些缺点，通常使用来自知名颁发者（称为证书颁发机构 (CA)）发放的证书配置服务器。主机平台一般包含其信任的知名 CA 的列表。从 Android 4.2 (Jelly Bean) 开始，Android 目前包含在每个版本中更新的 100 多个 CA。CA 具有一个证书和一个私钥，这点与服务器相似。为服务器发放证书时，CA 使用其私钥签署服务器证书。然后，客户端可以验证该服务器是否具有平台已知的 CA 发放的证书。</p>
<p>不过，在解决一些问题的同时，使用 CA 也会引发其他问题。因为 CA 为许多服务器发放证书，因此，您仍需要某种方式来确保您与您需要的服务器通信。为解决这个问题，CA 发放的证书通过 gmail.com 等具体名称或 *.google.com 等通配型主机集识别服务器。</p>
<p>以下示例会让这些概念更具体。下面的代码段来自命令行，openssl 工具的 s_client 命令将查看 Wikipedia 的服务器证书信息。它指定端口 443，因为此端口是 HTTPS的默认端口。此命令将 openssl s_client 的输出发送到 openssl x509，后者将根据 X.509 标准格式化与证书有关的信息。具体而言，此命令会要求相关主题，主题包含服务器名称信息和可识别 CA 的颁发者。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl s_client -connect wikipedia.org:443 | openssl x509 -noout -subject -issuer</span></span><br><span class="line">subject= /serialNumber=sOrr2rKpMVP70Z6E9BT5reY008SJEdYv/C=US/O=*.wikipedia.org/OU=GT03314600/OU=See www.rapidssl.com/resources/cps (c)11/OU=Domain Control Validated - RapidSSL(R)/CN=*.wikipedia.org</span><br><span class="line">issuer= /C=US/O=GeoTrust, Inc./CN=RapidSSL CA</span><br></pre></td></tr></table></figure>
<p>您会看到证书是由 RapidSSL CA 为与 *.wikipedia.org 匹配的服务器发放的。</p>
<h4 id="一个-HTTPS-示例"><a href="#一个-HTTPS-示例" class="headerlink" title="一个 HTTPS 示例"></a>一个 HTTPS 示例</h4><p>假设您有一个由知名 CA 发放证书的网络服务器，那么，您可以使用如下简单代码发起安全的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://wikipedia.org&quot;</span>);</span><br><span class="line"><span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">copyInputStreamToOutputStream(in, System.out);</span><br></pre></td></tr></table></figure>

<p>没错，就这么简单。如果您要调整 HTTP 请求，您可以切换到 HttpURLConnection。有关 HttpURLConnection 的 Android 文档就如何处理请求和响应标头，以及如何发布内容、管理 Cookie、使用代理、缓存响应等提供了更多示例。但对于验证证书和主机名的细节，Android 框架在 API 中为您考虑了这些细节。这些是您尽可能想要实现的目标。不过，下面还有一些其他注意事项。</p>
<h4 id="验证服务器证书的常见问题"><a href="#验证服务器证书的常见问题" class="headerlink" title="验证服务器证书的常见问题"></a>验证服务器证书的常见问题</h4><p>假设没有从 getInputStream() 接收内容，将引发异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor <span class="keyword">for</span> certification path not found.</span><br><span class="line">        at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:<span class="number">374</span>)</span><br><span class="line">        at libcore.net.http.HttpConnection.setupSecureSocket(HttpConnection.java:<span class="number">209</span>)</span><br><span class="line">        at libcore.net.http.HttpsURLConnectionImpl$HttpsEngine.makeSslConnection(HttpsURLConnectionImpl.java:<span class="number">478</span>)</span><br><span class="line">        at libcore.net.http.HttpsURLConnectionImpl$HttpsEngine.connect(HttpsURLConnectionImpl.java:<span class="number">433</span>)</span><br><span class="line">        at libcore.net.http.HttpEngine.sendSocketRequest(HttpEngine.java:<span class="number">290</span>)</span><br><span class="line">        at libcore.net.http.HttpEngine.sendRequest(HttpEngine.java:<span class="number">240</span>)</span><br><span class="line">        at libcore.net.http.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:<span class="number">282</span>)</span><br><span class="line">        at libcore.net.http.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:<span class="number">177</span>)</span><br><span class="line">        at libcore.net.http.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:<span class="number">271</span>)</span><br></pre></td></tr></table></figure>
<p>出现此情况的原因有很多，其中包括： </p>
<ol>
<li>颁发服务器证书的 CA 未知</li>
<li>服务器证书不是由 CA 签署的，而是自签署</li>
<li>服务器配置缺少中间 CA</li>
</ol>
<p>下面几部分将讨论如何解决这些问题，同时保持与服务器的连接处于安全状态。 </p>
<h5 id="未知的证书颁发机构"><a href="#未知的证书颁发机构" class="headerlink" title="未知的证书颁发机构"></a>未知的证书颁发机构</h5><p>在这种情况下，由于您具有系统不信任的 CA，将发生 SSLHandshakeException。原因可能是您有一个来自 Android 还未信任的新 CA 的证书，或您的应用在没有 CA 的较旧版本上运行。CA 未知的原因通常是因为它不是公共 CA，而是政府、公司或教育机构等组织发放的仅供自己使用的私有 CA。</p>
<p>幸运的是，您可以指示 HttpsURLConnection 信任特定的 CA 集。此过程可能有点复杂，下面的示例展示了这个过程，从 InputStream 获取一个特定的 CA，用该 CA 创建 KeyStore，然后用后者创建和初始化 TrustManager。TrustManager 是系统用于从服务器验证证书的工具，可以使用一个或多个 CA 从 KeyStore 创建，而创建的 TrustManager 将仅信任这些 CA。</p>
<p>如果是新的 TrustManager，此示例将初始化一个新的 SSLContext，后者可以提供一个 SSLSocketFactory，您可以通过 HttpsURLConnection 用它来替换默认的 SSLSocketFactory。这样一来，连接将使用您的 CA 验证证书。</p>
<p>下面是使用华盛顿大学的机构 CA 的完整示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load CAs from an InputStream</span></span><br><span class="line"><span class="comment">// (could be from a resource or ByteArrayInputStream or ...)</span></span><br><span class="line"><span class="type">CertificateFactory</span> <span class="variable">cf</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line"><span class="comment">// From https://www.washington.edu/itconnect/security/ca/load-der.crt</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">caInput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;load-der.crt&quot;</span>));</span><br><span class="line">Certificate ca;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ca = cf.generateCertificate(caInput);</span><br><span class="line">    System.out.println(<span class="string">&quot;ca=&quot;</span> + ((X509Certificate) ca).getSubjectDN());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    caInput.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a KeyStore containing our trusted CAs</span></span><br><span class="line"><span class="type">String</span> <span class="variable">keyStoreType</span> <span class="operator">=</span> KeyStore.getDefaultType();</span><br><span class="line"><span class="type">KeyStore</span> <span class="variable">keyStore</span> <span class="operator">=</span> KeyStore.getInstance(keyStoreType);</span><br><span class="line">keyStore.load(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">keyStore.setCertificateEntry(<span class="string">&quot;ca&quot;</span>, ca);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a TrustManager that trusts the CAs in our KeyStore</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tmfAlgorithm</span> <span class="operator">=</span> TrustManagerFactory.getDefaultAlgorithm();</span><br><span class="line"><span class="type">TrustManagerFactory</span> <span class="variable">tmf</span> <span class="operator">=</span> TrustManagerFactory.getInstance(tmfAlgorithm);</span><br><span class="line">tmf.init(keyStore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an SSLContext that uses our TrustManager</span></span><br><span class="line"><span class="type">SSLContext</span> <span class="variable">context</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">context.init(<span class="literal">null</span>, tmf.getTrustManagers(), <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the URLConnection to use a SocketFactory from our SSLContext</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://certs.cac.washington.edu/CAtest/&quot;</span>);</span><br><span class="line"><span class="type">HttpsURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span></span><br><span class="line">    (HttpsURLConnection)url.openConnection();</span><br><span class="line">urlConnection.setSSLSocketFactory(context.getSocketFactory());</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">copyInputStreamToOutputStream(in, System.out);</span><br></pre></td></tr></table></figure>
<p>借助一个知道您的 CA 的自定义 TrustManager，系统能够验证您的服务器证书是否来自值得信任的颁发者。</p>
<blockquote>
<p>注意：许多网站都会介绍一个糟糕的替代解决方案，让您安装一个没用的 TrustManager。如果您这样做还不如不加密通信，因为任何人都可以在公共 WLAN 热点下，使用伪装成您的服务器的代理发送您的用户流量，通过 DNS 欺骗攻击您的用户。然后，攻击者可以记录密码和其他个人数据。此方法之所以有效是因为攻击者可以生成一个证书，且没有可以切实验证证书是否来自值得信任的来源的 TrustManager，从而使您的应用可与任何人通信。因此，不要这样做，暂时性的也不行。如果您可以始终让您的应用信任服务器证书的颁发者，那就这样做吧。</p>
</blockquote>
<h5 id="自签署的服务器证书"><a href="#自签署的服务器证书" class="headerlink" title="自签署的服务器证书"></a>自签署的服务器证书</h5><p>导致出现 SSLHandshakeException 的第二种情况是自签署证书，表示服务器将按照自己的 CA 进行操作。这与证书颁发机构未知的情况相似，因此，您可以使用前面部分介绍的方法。</p>
<p>您可以创建自己的 TrustManager，这次直接信任服务器证书。这种方法具有前面所述的将应用与证书直接关联的所有弊端，但可以安全地操作。不过，您应谨慎为之，以确保您的自签署证书具有合理的强密钥。从 2012 年开始，可以接受一个指数为 65537 的 2048 位 RSA 签名，此签名的有效期为一年。旋转密钥时，您应查看颁发机构（例如 NIST）针对可接受的密钥提供的建议。</p>
<h5 id="缺少中间证书颁发机构"><a href="#缺少中间证书颁发机构" class="headerlink" title="缺少中间证书颁发机构"></a>缺少中间证书颁发机构</h5><p>导致出现 SSLHandshakeException 的第三种情况是缺少中间 CA。大多数公共 CA 不直接签署服务器证书。相反，它们使用自己的主要 CA 证书（称为根 CA）签署中间 CA。这样一来，根 CA 可以离线存储，从而降低泄露风险。不过，Android 等操作系统通常仅直接信任根 CA，这会在服务器证书（由中间 CA 签署）与证书验证程序（了解根 CA）之间留下一个小的信任缺口。为了解决这个问题，服务器在 SSL 握手期间不会仅向客户端发送它的证书，而是发送一个证书链，包括服务器 CA 以及到达可信的根 CA 所需要的任意中间证书。</p>
<p>要了解其实际应用，请看一下通过 openssl s_client 命令查看的 mail.google.com 证书链：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl s_client -connect mail.google.com:443</span></span><br><span class="line">---</span><br><span class="line">Certificate chain</span><br><span class="line"> 0 s:/C=US/ST=California/L=Mountain View/O=Google Inc/CN=mail.google.com</span><br><span class="line">   i:/C=ZA/O=Thawte Consulting (Pty) Ltd./CN=Thawte SGC CA</span><br><span class="line"> 1 s:/C=ZA/O=Thawte Consulting (Pty) Ltd./CN=Thawte SGC CA</span><br><span class="line">   i:/C=US/O=VeriSign, Inc./OU=Class 3 Public Primary Certification Authority</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这表明服务器会为 mail.google.com 发送一个由 Thawte SGC CA（中间 CA）发放的证书，同时为 Thawte SGC CA 发送一个由 Verisign CA（Android 信任的主要 CA）发放的证书。</p>
<p>不过，对服务器进行配置以便不添加必要的中间 CA 也是屡见不鲜。例如，下面的服务器会引发 Android 浏览器错误和 Android 应用异常：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl s_client -connect egov.uscis.gov:443</span></span><br><span class="line">---</span><br><span class="line">Certificate chain</span><br><span class="line"> 0 s:/C=US/ST=District Of Columbia/L=Washington/O=U.S. Department of Homeland Security/OU=United States Citizenship and Immigration Services/OU=Terms of use at www.verisign.com/rpa (c)05/CN=egov.uscis.gov</span><br><span class="line">   i:/C=US/O=VeriSign, Inc./OU=VeriSign Trust Network/OU=Terms of use at https://www.verisign.com/rpa (c)10/CN=VeriSign Class 3 International Server CA - G3</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>有趣的是，在大多数桌面浏览器中访问此服务器不会引发完全未知的 CA 或自签署服务器证书所引发的类似错误。这是因为大多数桌面浏览器都会将可信的中间 CA 缓存一段时间。当浏览器从某个网站访问和了解中间 CA 后，下次它就不需要将中间 CA 添加在证书链中。</p>
<p>有些网站会专门为提供资源的辅助网络服务器这样做。例如，他们可能让具有完整证书链的服务器提供主 HTML 页面，让不包含 CA 的服务器提供图像、CSS 或 JavaScript 等资源，以节省带宽。遗憾的是，这些服务器有时候可能会提供您正在尝试从 Android 应用调用的网络服务，这一点让人难以接受。</p>
<p>可以通过两种方法解决此问题：</p>
<ul>
<li>配置服务器以便在服务器链中添加中间 CA。大多数 CA 都可以提供有关如何为所有常用网络服务器执行此操作的文档。如果您需要网站至少通过 Android 4.2 使用默认 Android 浏览器，那么这是唯一的方法。</li>
<li>或者，像对待其他任何未知 CA 一样对待中间 CA，并创建一个 TrustManager 以直接信任它，如前面的两部分中所述。</li>
</ul>
<h4 id="主机名验证的常见问题"><a href="#主机名验证的常见问题" class="headerlink" title="主机名验证的常见问题"></a>主机名验证的常见问题</h4><p>正如本文开头所述，验证 SSL 连接有两个关键环节。首先是验证证书是否来自值得信任的来源，这是前面部分重点讲述的内容。而此部分侧重于第二个环节：确保您正在通信的服务器提供正确的证书。如果没有提供，您通常会看到类似于下面的错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ava.io.IOException: Hostname <span class="string">&#x27;example.com&#x27;</span> was not verified</span><br><span class="line">        at libcore.net.http.HttpConnection.verifySecureSocketHostname(HttpConnection.java:<span class="number">223</span>)</span><br><span class="line">        at libcore.net.http.HttpsURLConnectionImpl$HttpsEngine.connect(HttpsURLConnectionImpl.java:<span class="number">446</span>)</span><br><span class="line">        at libcore.net.http.HttpEngine.sendSocketRequest(HttpEngine.java:<span class="number">290</span>)</span><br><span class="line">        at libcore.net.http.HttpEngine.sendRequest(HttpEngine.java:<span class="number">240</span>)</span><br><span class="line">        at libcore.net.http.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:<span class="number">282</span>)</span><br><span class="line">        at libcore.net.http.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:<span class="number">177</span>)</span><br><span class="line">        at libcore.net.http.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:<span class="number">271</span>)</span><br></pre></td></tr></table></figure>

<p>出现此错误的一个原因是服务器配置错误。配置服务器所使用的证书不具有与您尝试连接的服务器匹配的主题或主题备用名称字段。许多不同的服务器可能使用一个证书。例如，使用 openssl s_client -connect google.com:443 | openssl x509 -text 查看 google.com 证书，您不仅可以看到一个支持 *.google.com 的主题，而且还能看到适用于 <em>.youtube.com、</em>.android.com 等的主题备用名称。仅当您要连接的服务器名称没有被证书列为可接受时才会发生这种错误。</p>
<p>不幸的是，还有另外一个原因也会引发此错误，即虚拟托管。当多个使用 HTTP 的主机名共享服务器时，网络服务器可以通过 HTTP&#x2F;1.1 请求识别客户端正在寻找哪个目标主机名。遗憾的是，使用 HTTPS 会使情况变得复杂，因为服务器必须在看到 HTTP 请求前知道返回哪个证书。为了解决此问题，较新的 SSL 版本（特别是 TLSv.1.0 及更高版本）支持服务器名称指示 (SNI)，后者允许 SSL 客户端向服务器指定预期的主机名，以便可以返回正确的证书。</p>
<p>幸运的是，自 Android 2.3 开始，HttpsURLConnection 就支持 SNI。如果您需要支持 Android 2.2（及更旧的版本），一种解决办法是在一个唯一端口上设置备用虚拟主机，以便了解要返回哪个服务器证书。</p>
<p>比较极端的替代方法是不使用服务器默认情况下返回的验证程序，而是将 HostnameVerifier 替换为不使用您的虚拟机主机名的验证程序。</p>
<blockquote>
<p>注意：如果其他虚拟主机不在您的控制之下，则更换 HostnameVerifier 非常危险，因为中间人攻击会在您不知情的情况下将流量引向其他服务器。</p>
</blockquote>
<p>如果您仍确定要替换主机名验证，请看下面的示例，它将针对单个 URLConnection 的验证程序替换为确认主机名至少符合应用预期的验证程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an HostnameVerifier that hardwires the expected hostname.</span></span><br><span class="line"><span class="comment">// Note that is different than the URL&#x27;s hostname:</span></span><br><span class="line"><span class="comment">// example.com versus example.org</span></span><br><span class="line"><span class="type">HostnameVerifier</span> <span class="variable">hostnameVerifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostnameVerifier</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String hostname, SSLSession session)</span> &#123;</span><br><span class="line">        <span class="type">HostnameVerifier</span> <span class="variable">hv</span> <span class="operator">=</span></span><br><span class="line">            HttpsURLConnection.getDefaultHostnameVerifier();</span><br><span class="line">        <span class="keyword">return</span> hv.verify(<span class="string">&quot;example.com&quot;</span>, session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the URLConnection to use our HostnameVerifier</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://example.org/&quot;</span>);</span><br><span class="line"><span class="type">HttpsURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span></span><br><span class="line">    (HttpsURLConnection)url.openConnection();</span><br><span class="line">urlConnection.setHostnameVerifier(hostnameVerifier);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">copyInputStreamToOutputStream(in, System.out);</span><br></pre></td></tr></table></figure>

<p>但请记住，如果您发现自己更换了主机名验证，特别是因虚拟托管引起的更换，那么，当其他虚拟主机不在您的控制之下时，这样做仍非常危险，您应找到一个可以避免此问题的备用托管安排。</p>
<h4 id="有关直接使用-SSLSocket-的警告"><a href="#有关直接使用-SSLSocket-的警告" class="headerlink" title="有关直接使用 SSLSocket 的警告"></a>有关直接使用 SSLSocket 的警告</h4><p>到目前为止，所举示例都是侧重于使用 HttpsURLConnection 的 HTTPS。有时候应用需要单独使用 SSL与 HTTP。例如，某个电子邮件应用可能使用 SSL 的变体 SMTP、POP3 或 IMAP。在这些情况下，应用将需要直接使用 SSLSocket，与 HttpsURLConnection 在内部执行的操作非常相似。</p>
<p>目前为止所介绍的用于处理证书验证问题的技术也适用于 SSLSocket。事实上，使用自定义 TrustManager 时，传递到 HttpsURLConnection 的是 SSLSocketFactory。因此，如果您需要使用一个带有 SSLSocket 的自定义 TrustManager，请遵循相同的步骤，并使用 SSLSocketFactory 创建您的 SSLSocket。</p>
<blockquote>
<p>注意：SSLSocket 不会执行主机名验证。由您的应用执行自己的主机名验证，最好通过使用预期的主机名调用 getDefaultHostnameVerifier() 进行验证。另外，请注意，出现错误时，HostnameVerifier.verify() 不会引发异常，而是返回一个布尔结果，您必须明确地检查该结果。</p>
</blockquote>
<p>以下示例向您展示了如何执行此操作。该示例显示在没有 SNI 支持的情况下连接到 gmail.com 端口 443 时，您将收到 mail.google.com 的证书。在此情况下，这正是期待的结果，因此，请执行检查以确保证书确实是 mail.google.com 的证书：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open SSLSocket directly to gmail.com</span></span><br><span class="line"><span class="type">SocketFactory</span> <span class="variable">sf</span> <span class="operator">=</span> SSLSocketFactory.getDefault();</span><br><span class="line"><span class="type">SSLSocket</span> <span class="variable">socket</span> <span class="operator">=</span> (SSLSocket) sf.createSocket(<span class="string">&quot;gmail.com&quot;</span>, <span class="number">443</span>);</span><br><span class="line"><span class="type">HostnameVerifier</span> <span class="variable">hv</span> <span class="operator">=</span> HttpsURLConnection.getDefaultHostnameVerifier();</span><br><span class="line"><span class="type">SSLSession</span> <span class="variable">s</span> <span class="operator">=</span> socket.getSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that the certicate hostname is for mail.google.com</span></span><br><span class="line"><span class="comment">// This is due to lack of SNI support in the current SSLSocket.</span></span><br><span class="line"><span class="keyword">if</span> (!hv.verify(<span class="string">&quot;mail.google.com&quot;</span>, s)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SSLHandshakeException</span>(<span class="string">&quot;Expected mail.google.com, &quot;</span></span><br><span class="line">                                    <span class="string">&quot;found &quot;</span> + s.getPeerPrincipal());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// At this point SSLSocket performed certificate verificaiton and</span></span><br><span class="line"><span class="comment">// we have performed hostname verification, so it is safe to proceed.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... use socket ...</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<h4 id="列入黑名单"><a href="#列入黑名单" class="headerlink" title="列入黑名单"></a>列入黑名单</h4><p>为了仅向正确验证的服务器和域的所有者发放证书，SSL 非常依赖 CA。少数情况下，CA 也会受骗，如 Comodo 和 DigiNotar 出现了信息泄露，从而导致某个主机名的证书被发放给服务器或域的所有者以外的其他人。</p>
<p>为了降低此风险，Android 提供了将某些证书甚至整个 CA 列入黑名单的功能。尽管此名单过去已内置到操作系统中，但从 Android 4.2 开始，可以远程更新此名单，便于处理将来的泄露问题。</p>
<h4 id="证书固定"><a href="#证书固定" class="headerlink" title="证书固定"></a>证书固定</h4><p>通过名称为证书固定的技术，应用可以更好地保护自己免受以欺诈方式发放的证书的攻击。这里基本上使用上面未知 CA 案例中提供的示例，将应用的可信 CA 限制在一个很小的 CA 集范围内，应用的服务器将使用这个集合。这样可以防止因泄露系统中其他 100 多个 CA 中的某个 CA 而破坏应用安全通道。</p>
<h4 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a>客户端证书</h4><p>本文重点讲述 SSL 用户与服务器进行安全通信。SSL 也支持客户端证书的概念，客户端证书允许服务器验证客户端的身份。尽管这超出了本文的讨论范围，但使用的技术与指定自定义 TrustManager 相似。请在 HttpsURLConnection 的相关文档中查看有关创建自定义 KeyManager 的讨论。</p>
<h4 id="Nogotofail：网络流量安全测试工具"><a href="#Nogotofail：网络流量安全测试工具" class="headerlink" title="Nogotofail：网络流量安全测试工具"></a>Nogotofail：网络流量安全测试工具</h4><p> 对于已知的 TLS&#x2F;SSL 漏洞和错配置，可以通过 Nogotofail 轻松确认您的应用程序是否安全。它是一款自动执行的工具，功能强大并且可扩展，用于测试通过它传送网络流量的任意设备的网络安全问题。</p>
<p>Nogotofail 可用于三个主要用例：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查找错误和漏洞。</span><br><span class="line">验证修复并监测回归。</span><br><span class="line">了解哪些应用和设备正在生成哪些流量。</span><br></pre></td></tr></table></figure>

<p>Nogotofail 适用于 Android、iOS、Linux、Windows、Chrome 操作系统、OSX。事实上，任何用于连接互联网的设备都可以使用 Nogotofail。在 Android 和 Linux 上提供了一个易于使用的客户端来配置设置和获取通知，同时还提供了一个本身可作为路由器、VPN 服务器或代理部署的攻击引擎。</p>
<p>您可以在 <a target="_blank" rel="noopener" href="https://github.com/google/nogotofail">Nogotofail</a> 开源项目网站上访问此工具。 </p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Linux/Nogotofail%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/" rel="prev" title="Nogotofail网络流量安全测试工具">
      <i class="fa fa-chevron-left"></i> Nogotofail网络流量安全测试工具
    </a></div>
      <div class="post-nav-item">
    <a href="/Android/%E5%86%99%E4%B8%80%E4%B8%AAVolley%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82/" rel="next" title="写一个Volley自定义Request">
      写一个Volley自定义Request <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA-HTTPS-%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.</span> <span class="nav-text">一个 HTTPS 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">验证服务器证书的常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AA%E7%9F%A5%E7%9A%84%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">未知的证书颁发机构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%AD%BE%E7%BD%B2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6"><span class="nav-number">3.2.</span> <span class="nav-text">自签署的服务器证书</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E5%B0%91%E4%B8%AD%E9%97%B4%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">缺少中间证书颁发机构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA%E5%90%8D%E9%AA%8C%E8%AF%81%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">主机名验证的常见问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-SSLSocket-%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="nav-number">5.</span> <span class="nav-text">有关直接使用 SSLSocket 的警告</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E5%85%A5%E9%BB%91%E5%90%8D%E5%8D%95"><span class="nav-number">6.</span> <span class="nav-text">列入黑名单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%81%E4%B9%A6%E5%9B%BA%E5%AE%9A"><span class="nav-number">7.</span> <span class="nav-text">证书固定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%81%E4%B9%A6"><span class="nav-number">8.</span> <span class="nav-text">客户端证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nogotofail%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-number">9.</span> <span class="nav-text">Nogotofail：网络流量安全测试工具</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KevinWen"
      src="/images/custom/avatar_samwen.jpg">
  <p class="site-author-name" itemprop="name">KevinWen</p>
  <div class="site-description" itemprop="description">做人如果没有梦想,和咸鱼有什么区别呢?</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">367</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kevinvane" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kevinvane" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kevinvane@outlook.com" title="E-Mail → kevinvane@outlook.com"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/kevinvane" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;kevinvane" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/kevinvane" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;kevinvane" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/kevinvane" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;kevinvane" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KevinWen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
